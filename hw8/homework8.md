## 41911231 王聪
# SOLID
### SOLID 原则其实是用来指导软件设计的，它一共分为五条设计原则，分别是：

>- 单一职责原则（SRP）
>- 开闭原则（OCP）
>- 里氏替换原则（LSP）
>- 接口隔离原则（ISP）
>- 依赖倒置原则（DIP）

## 1 SRP
>### 面向对象编程中，核心思想之一是将数据和对数据的操作封装到一起，通过抽象来形成类的概念。某一类中对数据的操作可以有很多种，从而让这个类承担多个类型责任。而SRP原则表示，应当让类中的功能种类单一（并不是说只写一个功能），从而避免功能种类过多时，种类与种类之间的关联性，达到提高内聚性，降低复杂性。例如，一个类如果既能对数据进行运算又能对数据进行显示，这是违反单一原则的，应该用两个类分别实现对数据的运算和显示。我认为，SRP可以看作是对封装的一个提升，类确实可以封装功能，封装功能不是越多越好，为了便于代码可读和维护性，应该将类的功能变得单一。
## 2 OCP
>### 2.1 ocp原则————你可以对在我的类中添加你的代码（open），但是你的代码不能改变我的(close)。大概的意思类似于“你只能在我允许的范围中变化”。

>### 2.2 在具体实现方面，可以理解为软件实体分为两部分，一部分是相对稳定的抽象层，另一部分是相同的可变因素。我的理解是，一个类是可以有变化的，但是我的核心是不能变的，其他的是可以变化的。我认为,这里是继承和多态的体现。
## 3 LSP

>### 3.1 里氏替换原则是实现开闭原则的重要方式之一。

>### 3.2 它克服了继承中重写父类造成的可复用性变差的缺点。

>### 3.3 它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。

>### 3.4 加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险。

>### 3.5用OCP和LSP理解继承，父类就是OCP中稳定层，而子类则是OCP中的可以变化的部分。
## 4 ISP

>### 4.1 降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。

>### 4.2 提高类的可读性。复杂性降低，自然其可读性会提高。

>### 4.3 提高系统的可维护性。可读性提高，那自然更容易维护了。

>### 4.4 变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。
## 5 DIP

>### 5.1 依赖倒置原则可以降低类间的耦合性。

>### 5.2 依赖倒置原则可以提高系统的稳定性。

>### 5.3 依赖倒置原则可以减少并行开发引起的风险。

>### 5.4 依赖倒置原则可以提高代码的可读性和可维护性。

# 我对SOLID原则的总结(耦合，内聚，泛用，多态，继承)
## solid的目的是优化代码，优化代码必须要降低耦合性，提高内聚性
- ### DIP 通过要面向接口的编程来降低类间的耦合性
- ### SRP和ISP都体现了封装的思想，但是二者又是不同，SRP注重职责，约束类，针对程序的实现和细节；ISP注重接口依赖的隔离，约束接口。
- ### OCP原则是代码最重要的组成部分，是代码的基本原则。DIP和LSP都是实现OCP的重要方式之一，体现了面向对象编程中的继承和多态思想。并且将代码划分为两部分，可变的扩展部分和不可变稳定曾部分。






